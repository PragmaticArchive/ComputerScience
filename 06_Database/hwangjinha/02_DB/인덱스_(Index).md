tags : #CS #DB

---
# 인덱스
## 목적
- 관계형 데이터베이스 시스템에서 검색 속도를 높임
- 컬름을 색인화 하여 따로 파일로 저장

## 과정
- 테이블의 생성하면, MYD, MYI, FRM 3개의 파일이 생성됨.
- MYD : 실제 데이터가 있는 파일.
- MYI : 인덱스 정보가 들어가 있는 파일.
- FRM : 테이블 구조가 저장되어 있는 파일.

## 인덱스 사용 시...
### 좋은 경우
- 대량의 데이터 검색
- 정렬된 결과 출력
- Join 연산 수행
- 검색 빈도가 높음

### 안 좋은 경우
- 데이터 중복도가 높음
- DML이 자주 일어남

### 단점
- 인덱스 생성 시 mdb 파일 크기가 증가
- 동시에 한 페이지를 수정하는 병행성이 감소
- DML이 일어나는 경우 성능이 떨어진다.

## 자료구조
### 1. 해시테이블(Hash Table)
- O(1) 이므로 속도가 빠르다.
- 충돌이 발생할 수 있다.
- 부등호 연산에 부적합
### 2. B- Tree
- 균형 잡힌 이진 검색 트리
- O(logN). 여전히 빠르지만 해시테이블에 비해 느리다.
- 항상 정렬된 상태를 유지한다.
### 3. B+Tree
- B-Tree와 기본적으로는 같다.
- 인덱스만이 내부 노드에 저장된다.
- 데이터는 단말 노드에만 저장된다.
	- Full Scan이 더 빠르다.

## 클러스터 인덱스 VS. 넌클러스터 인덱스
### 클러스터 인덱스
- 테이블당 하나씩 허용
- 물리적으로 행을 재배열
- PK 설정시 자동으로 클러스터 인덱스가 형성
- 테이블 자체가 인덱스 -> 인덱스 페이지 생성 x
### 넌클러스터 인덱스
- 많은 인덱스 생성 허용
- 레코드 원본은 정렬되지 않고, 인덱스 페이지만 정렬된다.
	- 검색은 클러스터보다 느림
	- 입력 수정 삭제는 클러스터보다 빠름
 - 인덱스 페이지를 생성하기 때문에 용량을 더 차지한다.