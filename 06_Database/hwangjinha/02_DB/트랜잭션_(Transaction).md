tags : #CS #DB #transaction #DBMS #lock

---
# 트랜잭션
## 정의
데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위.
- 상태를 변화시킨다는 것 : SQL 질의어를 통해 DB에 접근하는 것.
- 작업 단위 : 많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것.
- ex) 사용자 A가 사용자 B에게 만원을 송금한다.
<br>

- DB
	1. 사용자 A의 계좌에서 만원을 차감 -> update문을 통해 사용자 A의 잔액 변경
	2. 사용자 B의 계좌에 만원을 추가 -> update문을 통해 사용자 B의 잔액 변경
<br>

- commit
	- 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 얄려주기 위해 사용.
- rollback
	- 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우
 <br>

- 작업단위 = 출금 update 문 + 입금 update 문
	- 이를 통틀어 하나의 트랜잭션이라고 함
	- 위 2개의 쿼리문 모두 성공적으로 완료되어야만, "하나의 작업(트랜잭션)"이 완료됨 -> commit
	- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 되돌려놓음 -> rollback

## 트랜잭션 특징(ACID)
1. 원자성 (Atomicity)
	- 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 함.
2. 일관성 (Consistency)
	- 트랜잭션 작업 처리 결과는 항상 일관성 있어야 함.
	- 트랜잭션이 반영된 후에도 기존에 데이터베이스에 걸려있던 제약조건들을 만족.
3. 독립성 (Isolation)
	- 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없음.
4. 지속성 (Durability)
	- 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 함.

## 트랜잭션 관리를 위한 DBMS 전략
[[데이터베이스]]
이해를 위한 2가지 개념 : DBMS 구조 / Buffer 관리 정책.
- undo 정책
	- steal : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
		- 대부분의 DBMS가 채택하는 Buffer 관리 정책
		- UNDO logging과 복구를 필요로 함
	- not steal : 수정된 페이지들을 EOT (End Of Transaction)까지 버퍼에 유지하는 정책
		- UNDO 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함
  - redo 정책
	  - FORCE : 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영
		  - 트랜잭션이 커밋되었을 때 수정된 page들이 디스크 상에 반영되므로 REDO 필요없음.
	  - not FORCE : 커밋 시점에 반영하지 않음
		  - 트랜잭션이 디스크 상의 DB에 반영되지 않을 수 있으므로 REDO 복구가 필요(대부분의 DBMS 정책).

## 트랜잭션 격리 수준
- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준.

### 필요성
- 트랜잭션이 독립적인 수행을 할 수 있게 함
- Locking을 통해 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요함
- 낮은 수준으로 Locking : 잘못된 값이 처리될 가능성
- 높은 수준으로 Locking : DB 성능 저하

[[데이터베이스_락_(Lock)]]

### 종류
1. Read Uncommited (레벨 0)
- select 수행 동안 데이터에 Shared Lock이 걸리지 않는다.
- 트랜잭션 처리중 다른 트랜잭션이 데이터를 읽는 것을 허용한다.
> 데이터베이스 일관성 유지 불가능

2. Read Commited (레벨 1)
- select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸린다.
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기
- 커밋이 이뤄진 트랜잭션만 조회 가능 ⇒ 다른 트랜잭션 진행과정 중에 커밋이 발생하면 Repeatable Read를 보장하지 않음.
- 대부분의 SQL서버가 default로 사용

3. Repeatable Read (레벨2)
- 트랜잭션이 완료될 때까지 select 문장이 사용하는 모든 데이터에 Shared Lock이 걸린다.
- 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장 
	- 트랜잭션 시작 전에 커밋된 내용만 볼 수 있음
	- InnoDB의 경우 트랜잭션 번호를 순차적으로 부여하는데, Reapeatable Read 격리 수준을 따른다면 현재 자신의 트랜잭션 번호보다 낮은 트랜잭션들의 데이터만 조회.
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능.
- MySQL에서 default로 사용

4. Serializable (레벨 3)
- 트랜잭션이 완료될 때까지 select 문장이 사용하는 모든 데이터에 Shared Lock이 걸린다.
- 완벽한 읽기 일관성 모드를 제공.
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능.
> 성능에 좋지 않음.

낮은 단계 격리 수준을 활용할 때 발생하는 현상들
1. dirty read : commit 전의 수정중인 데이터 읽기
	- Read Uncommited
 2. Non-Repeatable Read : 한 트랜잭션에서 같은 두 쿼리의 결과가 다르게 나타남
	 - Read Committed, Read Uncommitted
3.  Phantom read : 한 트랜잭션에서 일정 범위의 레코드를 두번 이상 읽었을 때, 첫 번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
	- Repeatable Read, Read Committed, Read Uncommitted.