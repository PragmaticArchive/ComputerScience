# 프로세스 상태, CPU 스케줄링

---

### 스케줄링

CPU를 잘 사용하기 위해 프로세스의 작업순서를 잘 배정해야 함.

조건 : 오버헤드 ↓, 사용률 ↑, 기아현상 ↓.

목표 :

- Batch System : 가능한 많은 일을 수행. 시간(time)보다는 처리량(throghout)이 중요함.
- Interactive System : 빠른 응답 시간, 적은 대기 시간.
- Real-Time System : 기한(deadline) 맞추기.

---

### 프로세스 상태

프로세스가 실행되는 동안 변경되는 고유 상태.

- 생성(new) : 프로세스가 생성되고 아직 준비가 되지 않은 상태.
- 준비(ready) : 프로세스가 실행을 기다리는 상태. CPU를 할당받을 수 있는 상태이며, 언제든지 실행될 준비 완료.
- 실행(running) : 프로세스가 CPU를 할당받아 실행되는 상태.
- 대기(waiting) : 프로세스가 특정 이벤트(입출력 요청 등)가 발생하여 대기하는 상태. CPU를 할당받지 못하며, 이벤트가 발생하여 다시 READY 상태로 전환될 때까지 대기.
- 종료(terminate) : 프로세스가 실행을 완료하고 종료된 상태. 더이상 실행될 수 없으며 메모리에서 제거된다.

---

### 프로세스 상태 전이

<img width="695" alt="Untitled (2)" src="https://github.com/hgene0929/hgene0929/assets/90823532/7d152c37-8e91-4b98-bfdd-6b3143c3d806">

- Admitted(new → ready) : 프로세스 생성을 승인 받음.
- Dispatch(ready → Running) : 준비 상태에 있는 여러 프로세스들 중 하나가 스케줄러에 의해 실행됨.
- Interrupt(running → ready) : Timeout, 예기치 않은 이벤트가 발생하여 현재 실행 중이 프로세스를 준비 상태로 전환시키고, 해당 작업을 우선 처리.
- IO or Event Wait(running → waiting) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력이나 이벤트가 끝날때까지 대기 상태로 전환.
- IO or Event Completion(waiting → ready) : 입출력이나 이벤트가 모두 끝난 프로세스를 다시 준비 상태로 만들어 스케줄러에 의해 선택될 수 있는 상태로 전환.

---

### 선점/비선점 스케줄링

선점(preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수(처리시간 예측이 어려움).

비선점(nonpreemptive) : 프로세스 종료 or IO 등의 이벤트가 있을 때까지 실행 보장(처리시간 예측이 용이함).

---

### CPU 스케줄링 알고리즘

**1. 선입선처리 알고리즘(FCFS, First Come First Served)**

CPU를 먼저 요청하는(큐에 먼저 도착한) 프로세스가 CPU를 먼저 할당받음.

한계 : 실행 시간이 짧은게 뒤로 가면 평균 대기 시간이 대단히 길어짐 → 대화형 시스템에 적절하지 X.

비선점 스케줄링.
</br></br>

**2. 최단작업 우선 스케줄링(SJF, Shortest Job First)**

CPU 버스트 길이가 가장 작은(수행시간이 짧은순) 프로세스부터 순서대로 할당받음.

최소의 평균 대기 시간을 가짐 → 최적의 알고리즘.

한계 : 각 프로세스의 버스트 길이를 알 수 X → 예측해야 함.

선점 and 비선점 스케줄링.

- 선점 스케줄링 == 최단잔여시간 우선 스케줄링(SRT).
</br></br>

**3. 최단잔여시간 우선 스케줄링(SRT, Shortest Remaining Time)**

최단 잔여시간을 우선으로 하는 스케줄링.

진행 중인 프로세스가 있어도, 최단 잔여시간인 프로세스를 위해 멈추고 짧은 프로세스를 먼저 할당.

선점 스케줄링(선점형 SJF).
</br></br>

**4. 라운드 로빈 스케줄링(RR, Round Robin)**

시분할 시스템을 위해 설계된 스케줄링.

모든 프로세스가 같은 우선순위를 가지고, time slice(time quantum)를 기반으로 스케줄링.

CPU 스케줄러는 준비큐를 돌면서 한번에 하나의 프로세스에 한번의 시간 할당량 동안 CPU를 할당함.

한계 : time slice의 크기가 너무 크다면 FCFS와 다를 바가 없고, 너무 작다면 context switching이 너무 자주 발생함.

선점 스케줄링.
</br></br>

**5. 우선순위 스케줄링(Priority)**

우선순위가 각 프로세스들에 연관되어 있으며, CPU 코어는 가장 높은 우선순위를 가진 프로세스에 할당됨.

- 우선순위가 같은 프로세스들은 보통 FCFS 순으로 스케줄링 됨.

한계 : 기아 상태(starvation) 문제 발생 가능함 → aging 기법을 통해 해결해야함.

선점 스케줄링.

> 💡 **aging**
>
> 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킴

</br></br>
**6. 다단계 큐 스케줄링(Multilevel Queue)**

우선순위 스케줄링 + 라운드 로빈 스케줄링.

프로세스 유형에 따라 프로세스를 여러 개의 개별 큐로 분할하기 위해 다단계 큐 스케줄링 알고리즘 사용 가능.

- 각 큐에는 자체 스케줄링 알고리즘을 구현할 수 있음.

선점 스케줄링.

> 💡 **다단계 피드백 큐 스케줄링(Multilevel Feedback Queue)**
>
> 다단계 큐 스케줄링에서는 프로세스들이 영구적으로 하나의 큐에 할당되지만, 다단계 피드백 큐 스케줄링에서는 프로세스가 큐들 사이를 이동하는 것을 허용.
