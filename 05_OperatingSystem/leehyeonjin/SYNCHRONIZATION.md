# 프로세스 동기화

---

### 멀티 스레딩의 문제점

- 독립적인 프로세스 : 시스템에서 실행중인 다른 프로세스들에게 영향을 주거나 받지 않는 프로세스.
- 협력적인 프로세스 : 시스템에서 실행중인 다른 프로세스들에게 영향을 주거나 받는 프로세스.

스레드가 자원을 공유하기 때문에 다른 스레드가 사용중인 변수나 자료구조에 접근 가능한 상황.

협력적인 프로세스 환경(멀티 스레딩 환경)에서는 논리 주소 공간을 직접 공유하거나 파일 또는 메시지에 의해서 공유가 이루어짐.

이러한 경우, 데이터의 비일관성(비동기)을 초래할 수 있기 때문에 데이터의 일관성 유지를 위해 데이터나 흐름에 대한 동기화가 매우 중요.

---

### 프로세스 동기화

여러 프로세스가 하나의 공유된 자원을 동시에 접근하려고 할 때, 이들에게 순서를 정해줌으로써 공유하는 데이터의 일관성을 유지하는 것.

- 프로세스 동기화 : 하나의 자원은 한순간에 한 프로세스만 이용하도록 제어하는 것.
- 스레드 동기화 : 하나의 코드블록 or 메소드를 한순간에 하나의 스레드만이 이용하도록 보장하는 것.

> 💡 **경쟁상태(race condition)**
>
> 여러 프로세스/스레드가 공유 자원에 동시접근시, 그 순서에 따라 결과가 달라지는 문제.</br>
> 공유된 자원에서 여러 프로세스 및 스레드가 동시에 접근할 경우 경쟁상태 발생 가능.

**동기화 필요성**

- 데이터 일관성 보장.
- 원하는 결과값을 도출하도록 임계구역 문제 해결.
- 프로세스의 실행 순서를 원하는대로 제어.
- busy wait(의미없는 코드를 반복 수행하며 대기하는 상태)과 같은 비효율성 제거.

---

### 임계구역(Critical Section)

여러개의 스레드가 수행되는 시스템에서  각 스레드들이 공유하는 데이터를 변경하는 코드 영역.

공유 자원에 접근하는 코드의 일부로, 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스가 그들의 임계구역에 들어갈 수 없음.

- 임계구역 문제 : 임계구역을 지정되어야 할 코드 영역이 임계구역으로 지정되지 않았을 때 발생가능한 문제.
</br></br>

**임계구역 해결 조건 3가지**

1. 상호배제(Mutual Exclusion)

- 오류가 발생하지 않도록, 오직 하나의 스레드만 임계구역에 접근가능.

- 한 스레드(프로세스)가 임계구역에서 실행중이라면, 다른 스레드(프로세스)는 접근불가.

2. 진행(Progress)

- 임계구역에 프로세스가 존재하지 않는 경우, 다른 프로세스가 접근할 수 있도록 해줘야 함,

  - 임계구역에 들어갈 프로세스가 여러개라면, 어떤 프로세스가 들어가야할지를 결정.

- 유한 시간내에 이루어져야 함.

3. 유한 대기(Bounded Waiting)

- 다른 프로세스의 기아문제를 방지하기 위해, 한 번 임계구역에 들어간 프로세스는 그 다음 임계구역에 들어갈 때 제한을 두어야 함.

- 임계구역으로 진입하기 위해 대기하는 모든 스레드는 유한 시간 이내에 해당 임계구역으로 진입할 수 있어야 함.

> 💡 **진행 vs 유한대기**
>
> - 진행 : 임계구역 해결을 위해 코드 실행이 멈추지 않는 것을 의미.
> - 유한대기 : 임계구역 코드 실행에 들어간 프로세스 외 나머지 프로세스들이 기아 현상이 나타나지 않도록 하기 위해 이미 임계구역을 실행한 프로세스를 제한하는 것.

</br>

**임계구역 해결 방법 3가지(동기화 방법)**

1. Mutex(Mutual Exclusion)

- 이미 하나의 프로세스가 임계구역에서 작업중이라면, 다른 프로세스들은 임계구역에 접근할 수 없도록 함.

- 하나의 자원에 대해 동기화.

- 자신이 직접 자원을 할당받고, 해제해주어야 함.

- 단점 : busy waiting(spin lock) - lock이 반환할 때까지 대기중인 프로세스들이 계속 자원의 점유 상태를 확인하면서 기다리는 것.

```c
acquire() {
	while (!available); // busy wait
	available = false;
}

release() {
	available = true;
}

do {
	acquire lock;
	critical section;
	release lock;
} while(1);
```

2. Semaphores

- 여러 프로세스나 스레드가 임계구역에 진입할 수 있는 signaling 매커니즘.

- 카운터를 이용하여 동시에 자원에 접근가능한 프로세스 지원(S = 사용가능한 자원의 개수).

  - Counting Semaphore : 정수 값의 범위가 0 이상으로 제한이 없고, 주로 자원의 개수를 세는데 사용.
  - Binary Semaphore : 정수 값이 오직 0 or 1이고, Mutex와 동일한 역할.

  - 1개 이상의 작업에 대한 공유자원 처리 가능.

- 다른 작업에 의해 자원할당 해제 가능.

- Block & Wait 방식 : 임계구역 진입에 실패한 프로세스를 기다리게 하지 않고 block 시킨뒤 임계구역에 자리가 나면 다시 깨워줌.

  - → 일반적으로는 busy waiting에서의 CPU 낭비 문제를 해결해줌.

```c
typedef struct {
	int value;
	struct process *L;
} semaphore;

void wait(semaphore S) {
	S.value--;
	if (S.value < 0) {
		add this process to S.L;
		block();
	}
}

void signal(semaphore S) {
	S.value++;
	if (S.value <= 0) {
		remove a process P from S.L;
		wakeup(P);
	}
}
```

3. Monitor

- 동시 수행 중인 프로세스 사이에서 추상 데이터의 안전한 공유를 보장하기 위한 high-level 구조.

- 락(lock)을 걸 필요없이 모니터 내부 procedure를 통해 프로그래머가 직접 동기화를 해주지 않아도 됨.

---

### Thread-Safe

Thread-Safe : 여러 스레드가 동작하는 환경에서도 안전하고 결과가 정확하다는 의미.

Reentrant : 여러 스레드가 동시에 접근하여 수행하여도 문제가 없다는 의미.
</br></br>

**Java에서 Thread-Safe한 설계란?**

- synchronized 키워드를 공유할 자원에 붙임.
- 여러개의 락을 동시에 사용하고 싶거나, 락의 범위가 메소드를 넘어선다면 → 락을 위한 클래스를 생성하여 사용.
- 가장 권장 하는 방법 : 불변객체 생성 → final 키워드를 변수에 붙이고, setter를 없애고 생성자로만 값 초기화.
