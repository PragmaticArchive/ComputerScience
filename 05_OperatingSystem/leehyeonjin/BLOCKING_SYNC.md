# 블로킹 vs 논블로킹 / 동기 vs 비동기

---

### 동기(Synchronous) vs 비동기(Asynchronous)

> 요청한 작업에 대해 완료 여부를 신경 써서 작업을 “순차적”으로 수행할지 아닌지.

<img width="686" alt="Untitled" src="https://github.com/hgene0929/ComputerScience/assets/90823532/730379f0-80ef-476e-b990-8dfb847edae3">

동기는 작업 B가 완료되어야 다음 작업을 수행, 비동기는 작업 B의 완료 여부를 따지지 않고 바로 다음 작업을 수행.
</br></br>

**동기 특징**

설계가 매우 간단하고 직관적.

실제 CPU가 느려지는 것은 아니지만, 요청과 결과가 동시에 이루어져야 해서 결과가 주어질 때까지 다른 프로그램이 정지한 채로 대기해야 하므로 비동기식보다 비효율적.

⇒ 전체적인 시스템 성능 저하.
</br></br>

**비동기 특징**

요청한 작업에 대하여 완료 여부를 신경쓰지 않고 자신의 그다음 작업을 수행한다는 것은 IO 작업과 같은 느린 작업이 발생할 때, 기다리지 않고 다른 작업을 처리하면서 동시에 처리하여 멀티 작업을 진행 가능.

⇒ 전반적인 시스템 성능 향상에 도움.

동기식보다 복잡함.

---

### 블로킹 vs 논블로킹

> 현재 작업의 “흐름”이 block(차단, 대기) 되느냐 아니냐.

<img width="700" alt="Untitled (1)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/dbae526d-a38f-4473-8196-1dbfd978a310">

파일을 읽는 작업이 있을 때, 블로킹 방식으로 읽으면 파일을 다 읽을 때까지 대기하고, 논블로킹 방식으로 읽으면 파일을 다 읽지 않아도 다른 작업 수행 가능.

---

### 동기/비동기 + 블로킹/논블로킹 조합

<img width="662" alt="Untitled (2)" src="https://github.com/hgene0929/ComputerScience/assets/90823532/65dac4a4-765d-496d-80a7-c0ada958822e">

**1. Sync Blocking(동기 + 블로킹)**

다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고 (Blocking),

다른 작업의 완료 여부를 바로 받아 순차적으로 처리하는 (Sync) 방식.

- 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용.
</br></br>

**2. Async Non-Blocking(비동기 + 논블로킹)**

다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non-Blocking),

다른 작업의 결과를 바로 처리하지 않아서 작업 순서가 지켜지지 않는 (Async) 방식.

- 다른 작업의 결과가 자신의 작업에 영향을 주지 않은 경우에 활용.
</br></br>

**3. Sync Non-Blocking(동기 + 논블로킹)**

다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non-Blocking),

다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행하는 (Sync) 방식.

- 예를 들어, 여러 개의 파일을 읽어서 내용을 비교하는 작업 수행시, A,B,C 3개의 파일 중 A,B 파일을 읽은 결과가 반환되어야 C를 읽을 수 있기 때문에 A,B만 동시에 수행하고, C에 대한 작업은 A,B 작업 결과 반환 후, 실행.
</br></br>

**4. Async Blocking(비동기 + 블로킹)**

다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리고 (Blocking),

다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 (Async) 방식.

- 실무에서는 잘 사용하지 X.
- Sync Blocking과 작업 수행에 차이가 없음.
- JavaScript(Async) + MySQL(Non-Blocking) → 비동기 블로킹 방식
    - 이러한 조합은 개발자에게 혼동을 일으키고, 동기 블로킹 방식과 다를 것이 없음.
    - 그래서 Node.js로 서버 프로그래밍을 할 떄에는 async/await로 동기처리를 해주는 경우가 많음.
